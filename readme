
https://github.com/mohammedfuta2000/k8s-nginx-ingress
https://www.youtube.com/watch?v=MpovOI5eK58
# Deploy your stack
$ aws cloudformation create-stack \
  --stack-name democluster \
  --region us-east-2 \
  --template-body file://<path-to-infra> \
  --capabilities CAPABILITY_IAM
# connect to the clsuter
$ aws eks update-kubeconfig --region us-east-2 --name 6senseCluster

$ kubectl get pod -A   
# ##########correct

$ kubectl create ns ingress-nginx
# install the ingress controller and create a load balancer
# https://artifacthub.io/packages/helm/ingress-nginx/ingress-nginx
$ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
$ helm repo update
$ helm install ingress-nginx ingress-nginx/ingress-nginx -n ingress-nginx -f nginx-values.yaml

$ kubectl get all -n ingress-nginx   
$ kubectl get svc -n ingress-nginx
# ##########correct

# configure DNS # use a GoDaddy Domain with an AWS load balancer
https://kakoma.ug/code/how-to-use-a-godaddy-domain-with-an-aws-load-balancer/
# at route53 create a hosted zone
# create in it an Alias record named * pointing to the load balancer
# create a CNAME record named www to point to the domain record created above

# update goddady nameservers with the hosted zone nameservers
# add the record quote<my-domain> and point that to the ALB too

######################correctly done

# create backend services
$ Kubectl create ns backend 
$ kubectl apply -f ./deployment.yaml
$ kubectl apply -f ./deployment.yaml
$ kubectl get all -n backend

######################correctly done

# create an ingress (the ELB rules, direct what traffic to what abckend service)
$ kubectl apply -f ./ingress.yaml
$ kubectl -n backend get ingress  

# test the live website, caches are stored so use a differnet device
$ curl -li http://quote.mohammedfuta2000.com
# this will not work on the same computer once u start again

###################correctly done, now work on argocd

# install cert manager helm chart
$ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.crds.yaml
$ helm repo add jetstack https://charts.jetstack.io
$ helm repo update jetstack
$ kubectl create ns cert-manager 
# create cert-manager-values.yaml 
$ helm install cert-manager -n cert-manager --version v1.7.1 jetstack/cert-manager -f cert-manager-values.yaml
# tell cert manager to use letsencrypt as the issuer. this is the configuration in the issuer.yaml
$ kubectl apply -f issuer.yaml
# this creates the secfret (letsencrypt-nainx-private-key), cert-manager.io(crds)
kubectl get secrets/crds -n backend
# then modify the ingress to use lets encrypt, after creating issuer, then the orders will show up
$ kubectl apply -f ./ingress.yaml
$ kubectl -n backend get order
$ kubectl -n backend get certificaterequest

# enable proxy protocol so that your apps will have access to client IPs
# at nginx-values.yaml, add services and config
$ kubectl apply -f ./nginx-values.yaml
